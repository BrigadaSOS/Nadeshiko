/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import { ExpressRuntimeError, RequestInputType } from '@nahkies/typescript-express-runtime/errors';
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  SkipResponse,
  type StatusCode,
} from '@nahkies/typescript-express-runtime/server';
import { parseRequestInput, responseValidationFactory } from '@nahkies/typescript-express-runtime/zod-v3';
import { type NextFunction, type Request, type Response, Router } from 'express';
import { z } from 'zod/v3';
import type {
  t_Episode,
  t_EpisodeCreateParamSchema,
  t_EpisodeCreateRequestBodySchema,
  t_EpisodeDestroyParamSchema,
  t_EpisodeIndexParamSchema,
  t_EpisodeIndexQuerySchema,
  t_EpisodeListResponse,
  t_EpisodeShowParamSchema,
  t_EpisodeUpdateParamSchema,
  t_EpisodeUpdateRequestBodySchema,
  t_Error,
  t_Media,
  t_MediaCreateRequestBodySchema,
  t_MediaDestroyParamSchema,
  t_MediaIndexQuerySchema,
  t_MediaListResponse,
  t_MediaShowParamSchema,
  t_MediaUpdateParamSchema,
  t_MediaUpdateRequestBodySchema,
  t_Segment,
  t_SegmentCreateParamSchema,
  t_SegmentCreateRequestBodySchema,
  t_SegmentDestroyParamSchema,
  t_SegmentIndexParamSchema,
  t_SegmentIndexQuerySchema,
  t_SegmentListResponse,
  t_SegmentShowByUuidParamSchema,
  t_SegmentShowParamSchema,
  t_SegmentUpdateParamSchema,
  t_SegmentUpdateRequestBodySchema,
} from '../models.ts';
import type {
  EpisodeCreateRequestOutput,
  EpisodeIndexQueryOutput,
  EpisodeUpdateRequestOutput,
  MediaCreateRequestOutput,
  MediaIndexQueryOutput,
  MediaUpdateRequestOutput,
  SegmentCreateRequestOutput,
  SegmentIndexQueryOutput,
  SegmentUpdateRequestOutput,
} from '../outputTypes.ts';
import {
  s_Episode,
  s_EpisodeCreateRequest,
  s_EpisodeListResponse,
  s_EpisodeUpdateRequest,
  s_Error,
  s_Media,
  s_MediaCreateRequest,
  s_MediaListResponse,
  s_MediaUpdateRequest,
  s_Segment,
  s_SegmentCreateRequest,
  s_SegmentListResponse,
  s_SegmentUpdateRequest,
} from '../schemas.ts';

export type MediaIndexResponder = {
  with200(): ExpressRuntimeResponse<t_MediaListResponse>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type MediaIndex = (
  params: Params<void, MediaIndexQueryOutput, void, void>,
  respond: MediaIndexResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type MediaCreateResponder = {
  with201(): ExpressRuntimeResponse<t_Media>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type MediaCreate = (
  params: Params<void, void, MediaCreateRequestOutput, void>,
  respond: MediaCreateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type MediaShowResponder = {
  with200(): ExpressRuntimeResponse<t_Media>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type MediaShow = (
  params: Params<t_MediaShowParamSchema, void, void, void>,
  respond: MediaShowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type MediaUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_Media>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type MediaUpdate = (
  params: Params<t_MediaUpdateParamSchema, void, MediaUpdateRequestOutput, void>,
  respond: MediaUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type MediaDestroyResponder = {
  with200(): ExpressRuntimeResponse<{
    id?: number;
    message?: string;
  }>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type MediaDestroy = (
  params: Params<t_MediaDestroyParamSchema, void, void, void>,
  respond: MediaDestroyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type EpisodeIndexResponder = {
  with200(): ExpressRuntimeResponse<t_EpisodeListResponse>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type EpisodeIndex = (
  params: Params<t_EpisodeIndexParamSchema, EpisodeIndexQueryOutput, void, void>,
  respond: EpisodeIndexResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type EpisodeCreateResponder = {
  with201(): ExpressRuntimeResponse<t_Episode>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type EpisodeCreate = (
  params: Params<t_EpisodeCreateParamSchema, void, EpisodeCreateRequestOutput, void>,
  respond: EpisodeCreateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type EpisodeShowResponder = {
  with200(): ExpressRuntimeResponse<t_Episode>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type EpisodeShow = (
  params: Params<t_EpisodeShowParamSchema, void, void, void>,
  respond: EpisodeShowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type EpisodeUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_Episode>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type EpisodeUpdate = (
  params: Params<t_EpisodeUpdateParamSchema, void, EpisodeUpdateRequestOutput, void>,
  respond: EpisodeUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type EpisodeDestroyResponder = {
  with204(): ExpressRuntimeResponse<void>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type EpisodeDestroy = (
  params: Params<t_EpisodeDestroyParamSchema, void, void, void>,
  respond: EpisodeDestroyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type SegmentIndexResponder = {
  with200(): ExpressRuntimeResponse<t_SegmentListResponse>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type SegmentIndex = (
  params: Params<t_SegmentIndexParamSchema, SegmentIndexQueryOutput, void, void>,
  respond: SegmentIndexResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type SegmentCreateResponder = {
  with201(): ExpressRuntimeResponse<t_Segment>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type SegmentCreate = (
  params: Params<t_SegmentCreateParamSchema, void, SegmentCreateRequestOutput, void>,
  respond: SegmentCreateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type SegmentShowResponder = {
  with200(): ExpressRuntimeResponse<t_Segment>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type SegmentShow = (
  params: Params<t_SegmentShowParamSchema, void, void, void>,
  respond: SegmentShowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type SegmentUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_Segment>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type SegmentUpdate = (
  params: Params<t_SegmentUpdateParamSchema, void, SegmentUpdateRequestOutput, void>,
  respond: SegmentUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type SegmentDestroyResponder = {
  with204(): ExpressRuntimeResponse<void>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type SegmentDestroy = (
  params: Params<t_SegmentDestroyParamSchema, void, void, void>,
  respond: SegmentDestroyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type SegmentShowByUuidResponder = {
  with200(): ExpressRuntimeResponse<t_Segment>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type SegmentShowByUuid = (
  params: Params<t_SegmentShowByUuidParamSchema, void, void, void>,
  respond: SegmentShowByUuidResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type MediaImplementation = {
  mediaIndex: MediaIndex;
  mediaCreate: MediaCreate;
  mediaShow: MediaShow;
  mediaUpdate: MediaUpdate;
  mediaDestroy: MediaDestroy;
  episodeIndex: EpisodeIndex;
  episodeCreate: EpisodeCreate;
  episodeShow: EpisodeShow;
  episodeUpdate: EpisodeUpdate;
  episodeDestroy: EpisodeDestroy;
  segmentIndex: SegmentIndex;
  segmentCreate: SegmentCreate;
  segmentShow: SegmentShow;
  segmentUpdate: SegmentUpdate;
  segmentDestroy: SegmentDestroy;
  segmentShowByUuid: SegmentShowByUuid;
};

export function createMediaRouter(implementation: MediaImplementation): Router {
  const router = Router();

  const mediaIndexQuerySchema = z.object({
    limit: z.coerce.number().min(1).max(40).optional().default(20),
    cursor: z.coerce.number().min(0).optional().default(0),
    category: z.enum(['ANIME', 'JDRAMA']).optional(),
  });

  const mediaIndexResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_MediaListResponse],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // mediaIndex
  router.get(`/v1/media`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: parseRequestInput(mediaIndexQuerySchema, req.query, RequestInputType.QueryString),
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_MediaListResponse>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.mediaIndex(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(mediaIndexResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const mediaCreateRequestBodySchema = s_MediaCreateRequest;

  const mediaCreateResponseBodyValidator = responseValidationFactory(
    [
      ['201', s_Media],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // mediaCreate
  router.post(`/v1/media`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(mediaCreateRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with201() {
          return new ExpressRuntimeResponse<t_Media>(201);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.mediaCreate(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(mediaCreateResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const mediaShowParamSchema = z.object({ id: z.coerce.number() });

  const mediaShowResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_Media],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // mediaShow
  router.get(`/v1/media/:id`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(mediaShowParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_Media>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.mediaShow(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(mediaShowResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const mediaUpdateParamSchema = z.object({ id: z.coerce.number() });

  const mediaUpdateRequestBodySchema = s_MediaUpdateRequest;

  const mediaUpdateResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_Media],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // mediaUpdate
  router.patch(`/v1/media/:id`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(mediaUpdateParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: parseRequestInput(mediaUpdateRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_Media>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.mediaUpdate(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(mediaUpdateResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const mediaDestroyParamSchema = z.object({ id: z.coerce.number() });

  const mediaDestroyResponseBodyValidator = responseValidationFactory(
    [
      [
        '200',
        z.object({
          message: z.string().optional(),
          id: z.coerce.number().optional(),
        }),
      ],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // mediaDestroy
  router.delete(`/v1/media/:id`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(mediaDestroyParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<{
            id?: number;
            message?: string;
          }>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.mediaDestroy(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(mediaDestroyResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const episodeIndexParamSchema = z.object({ mediaId: z.coerce.number() });

  const episodeIndexQuerySchema = z.object({
    size: z.coerce.number().min(1).max(100).optional().default(50),
    cursor: z.coerce.number().optional().default(0),
  });

  const episodeIndexResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_EpisodeListResponse],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // episodeIndex
  router.get(`/v1/media/:mediaId/episodes`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(episodeIndexParamSchema, req.params, RequestInputType.RouteParam),
        query: parseRequestInput(episodeIndexQuerySchema, req.query, RequestInputType.QueryString),
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_EpisodeListResponse>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.episodeIndex(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(episodeIndexResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const episodeCreateParamSchema = z.object({ mediaId: z.coerce.number() });

  const episodeCreateRequestBodySchema = s_EpisodeCreateRequest;

  const episodeCreateResponseBodyValidator = responseValidationFactory(
    [
      ['201', s_Episode],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // episodeCreate
  router.post(`/v1/media/:mediaId/episodes`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(episodeCreateParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: parseRequestInput(episodeCreateRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with201() {
          return new ExpressRuntimeResponse<t_Episode>(201);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.episodeCreate(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(episodeCreateResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const episodeShowParamSchema = z.object({
    mediaId: z.coerce.number(),
    episodeNumber: z.coerce.number(),
  });

  const episodeShowResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_Episode],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // episodeShow
  router.get(`/v1/media/:mediaId/episodes/:episodeNumber`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(episodeShowParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_Episode>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.episodeShow(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(episodeShowResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const episodeUpdateParamSchema = z.object({
    mediaId: z.coerce.number(),
    episodeNumber: z.coerce.number(),
  });

  const episodeUpdateRequestBodySchema = s_EpisodeUpdateRequest;

  const episodeUpdateResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_Episode],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // episodeUpdate
  router.patch(
    `/v1/media/:mediaId/episodes/:episodeNumber`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(episodeUpdateParamSchema, req.params, RequestInputType.RouteParam),
          query: undefined,
          body: parseRequestInput(episodeUpdateRequestBodySchema, req.body, RequestInputType.RequestBody),
          headers: undefined,
        };

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Episode>(200);
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400);
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401);
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403);
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404);
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429);
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500);
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status);
          },
        };

        const response = await implementation.episodeUpdate(input, responder, req, res, next).catch((err) => {
          throw ExpressRuntimeError.HandlerError(err);
        });

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return;
        }

        const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

        res.status(status);

        if (body !== undefined) {
          res.json(episodeUpdateResponseBodyValidator(status, body));
        } else {
          res.end();
        }
      } catch (error) {
        next(error);
      }
    },
  );

  const episodeDestroyParamSchema = z.object({
    mediaId: z.coerce.number(),
    episodeNumber: z.coerce.number(),
  });

  const episodeDestroyResponseBodyValidator = responseValidationFactory(
    [
      ['204', z.undefined()],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // episodeDestroy
  router.delete(
    `/v1/media/:mediaId/episodes/:episodeNumber`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(episodeDestroyParamSchema, req.params, RequestInputType.RouteParam),
          query: undefined,
          body: undefined,
          headers: undefined,
        };

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204);
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400);
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401);
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403);
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404);
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429);
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500);
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status);
          },
        };

        const response = await implementation.episodeDestroy(input, responder, req, res, next).catch((err) => {
          throw ExpressRuntimeError.HandlerError(err);
        });

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return;
        }

        const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

        res.status(status);

        if (body !== undefined) {
          res.json(episodeDestroyResponseBodyValidator(status, body));
        } else {
          res.end();
        }
      } catch (error) {
        next(error);
      }
    },
  );

  const segmentIndexParamSchema = z.object({
    mediaId: z.coerce.number(),
    episodeNumber: z.coerce.number(),
  });

  const segmentIndexQuerySchema = z.object({
    size: z.coerce.number().min(1).max(100).optional().default(50),
    cursor: z.coerce.number().optional().default(0),
  });

  const segmentIndexResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_SegmentListResponse],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // segmentIndex
  router.get(
    `/v1/media/:mediaId/episodes/:episodeNumber/segments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(segmentIndexParamSchema, req.params, RequestInputType.RouteParam),
          query: parseRequestInput(segmentIndexQuerySchema, req.query, RequestInputType.QueryString),
          body: undefined,
          headers: undefined,
        };

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_SegmentListResponse>(200);
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400);
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401);
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403);
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404);
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429);
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500);
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status);
          },
        };

        const response = await implementation.segmentIndex(input, responder, req, res, next).catch((err) => {
          throw ExpressRuntimeError.HandlerError(err);
        });

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return;
        }

        const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

        res.status(status);

        if (body !== undefined) {
          res.json(segmentIndexResponseBodyValidator(status, body));
        } else {
          res.end();
        }
      } catch (error) {
        next(error);
      }
    },
  );

  const segmentCreateParamSchema = z.object({
    mediaId: z.coerce.number(),
    episodeNumber: z.coerce.number(),
  });

  const segmentCreateRequestBodySchema = s_SegmentCreateRequest;

  const segmentCreateResponseBodyValidator = responseValidationFactory(
    [
      ['201', s_Segment],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // segmentCreate
  router.post(
    `/v1/media/:mediaId/episodes/:episodeNumber/segments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(segmentCreateParamSchema, req.params, RequestInputType.RouteParam),
          query: undefined,
          body: parseRequestInput(segmentCreateRequestBodySchema, req.body, RequestInputType.RequestBody),
          headers: undefined,
        };

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_Segment>(201);
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400);
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401);
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403);
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404);
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429);
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500);
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status);
          },
        };

        const response = await implementation.segmentCreate(input, responder, req, res, next).catch((err) => {
          throw ExpressRuntimeError.HandlerError(err);
        });

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return;
        }

        const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

        res.status(status);

        if (body !== undefined) {
          res.json(segmentCreateResponseBodyValidator(status, body));
        } else {
          res.end();
        }
      } catch (error) {
        next(error);
      }
    },
  );

  const segmentShowParamSchema = z.object({
    mediaId: z.coerce.number(),
    episodeNumber: z.coerce.number(),
    id: z.coerce.number(),
  });

  const segmentShowResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_Segment],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // segmentShow
  router.get(
    `/v1/media/:mediaId/episodes/:episodeNumber/segments/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(segmentShowParamSchema, req.params, RequestInputType.RouteParam),
          query: undefined,
          body: undefined,
          headers: undefined,
        };

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Segment>(200);
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400);
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401);
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403);
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404);
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429);
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500);
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status);
          },
        };

        const response = await implementation.segmentShow(input, responder, req, res, next).catch((err) => {
          throw ExpressRuntimeError.HandlerError(err);
        });

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return;
        }

        const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

        res.status(status);

        if (body !== undefined) {
          res.json(segmentShowResponseBodyValidator(status, body));
        } else {
          res.end();
        }
      } catch (error) {
        next(error);
      }
    },
  );

  const segmentUpdateParamSchema = z.object({
    mediaId: z.coerce.number(),
    episodeNumber: z.coerce.number(),
    id: z.coerce.number(),
  });

  const segmentUpdateRequestBodySchema = s_SegmentUpdateRequest;

  const segmentUpdateResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_Segment],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // segmentUpdate
  router.patch(
    `/v1/media/:mediaId/episodes/:episodeNumber/segments/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(segmentUpdateParamSchema, req.params, RequestInputType.RouteParam),
          query: undefined,
          body: parseRequestInput(segmentUpdateRequestBodySchema, req.body, RequestInputType.RequestBody),
          headers: undefined,
        };

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_Segment>(200);
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400);
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401);
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403);
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404);
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429);
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500);
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status);
          },
        };

        const response = await implementation.segmentUpdate(input, responder, req, res, next).catch((err) => {
          throw ExpressRuntimeError.HandlerError(err);
        });

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return;
        }

        const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

        res.status(status);

        if (body !== undefined) {
          res.json(segmentUpdateResponseBodyValidator(status, body));
        } else {
          res.end();
        }
      } catch (error) {
        next(error);
      }
    },
  );

  const segmentDestroyParamSchema = z.object({
    mediaId: z.coerce.number(),
    episodeNumber: z.coerce.number(),
    id: z.coerce.number(),
  });

  const segmentDestroyResponseBodyValidator = responseValidationFactory(
    [
      ['204', z.undefined()],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // segmentDestroy
  router.delete(
    `/v1/media/:mediaId/episodes/:episodeNumber/segments/:id`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(segmentDestroyParamSchema, req.params, RequestInputType.RouteParam),
          query: undefined,
          body: undefined,
          headers: undefined,
        };

        const responder = {
          with204() {
            return new ExpressRuntimeResponse<void>(204);
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400);
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401);
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403);
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404);
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429);
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500);
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status);
          },
        };

        const response = await implementation.segmentDestroy(input, responder, req, res, next).catch((err) => {
          throw ExpressRuntimeError.HandlerError(err);
        });

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return;
        }

        const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

        res.status(status);

        if (body !== undefined) {
          res.json(segmentDestroyResponseBodyValidator(status, body));
        } else {
          res.end();
        }
      } catch (error) {
        next(error);
      }
    },
  );

  const segmentShowByUuidParamSchema = z.object({ uuid: z.string() });

  const segmentShowByUuidResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_Segment],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // segmentShowByUuid
  router.get(`/v1/media/segments/:uuid`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(segmentShowByUuidParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_Segment>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.segmentShowByUuid(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(segmentShowByUuidResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  return router;
}

export { createMediaRouter as createRouter };
export type { MediaImplementation as Implementation };
