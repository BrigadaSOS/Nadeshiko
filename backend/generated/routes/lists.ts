/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import { ExpressRuntimeError, RequestInputType } from '@nahkies/typescript-express-runtime/errors';
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  SkipResponse,
  type StatusCode,
} from '@nahkies/typescript-express-runtime/server';
import { parseRequestInput, responseValidationFactory } from '@nahkies/typescript-express-runtime/zod-v3';
import { type NextFunction, type Request, type Response, Router } from 'express';
import { z } from 'zod/v3';
import type {
  t_Error,
  t_List,
  t_ListAddItemParamSchema,
  t_ListAddItemRequestBodySchema,
  t_ListCreateRequestBodySchema,
  t_ListDestroyParamSchema,
  t_ListIndexQuerySchema,
  t_ListRemoveItemParamSchema,
  t_ListShowParamSchema,
  t_ListUpdateItemParamSchema,
  t_ListUpdateItemRequestBodySchema,
  t_ListUpdateParamSchema,
  t_ListUpdateRequestBodySchema,
  t_ListWithMedia,
} from '../models.ts';
import type { ListCreateRequestOutput, ListIndexQueryOutput } from '../outputTypes.ts';
import { s_Error, s_List, s_ListCreateRequest, s_ListWithMedia } from '../schemas.ts';

export type ListIndexResponder = {
  with200(): ExpressRuntimeResponse<t_List[]>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type ListIndex = (
  params: Params<void, ListIndexQueryOutput, void, void>,
  respond: ListIndexResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type ListCreateResponder = {
  with201(): ExpressRuntimeResponse<t_List>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type ListCreate = (
  params: Params<void, void, ListCreateRequestOutput, void>,
  respond: ListCreateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type ListShowResponder = {
  with200(): ExpressRuntimeResponse<t_ListWithMedia>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type ListShow = (
  params: Params<t_ListShowParamSchema, void, void, void>,
  respond: ListShowResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type ListUpdateResponder = {
  with200(): ExpressRuntimeResponse<t_List>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type ListUpdate = (
  params: Params<t_ListUpdateParamSchema, void, t_ListUpdateRequestBodySchema, void>,
  respond: ListUpdateResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type ListDestroyResponder = {
  with200(): ExpressRuntimeResponse<{
    id?: number;
    message?: string;
  }>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type ListDestroy = (
  params: Params<t_ListDestroyParamSchema, void, void, void>,
  respond: ListDestroyResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type ListAddItemResponder = {
  with201(): ExpressRuntimeResponse<{
    message?: string;
  }>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type ListAddItem = (
  params: Params<t_ListAddItemParamSchema, void, t_ListAddItemRequestBodySchema, void>,
  respond: ListAddItemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type ListUpdateItemResponder = {
  with200(): ExpressRuntimeResponse<{
    message?: string;
  }>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type ListUpdateItem = (
  params: Params<t_ListUpdateItemParamSchema, void, t_ListUpdateItemRequestBodySchema, void>,
  respond: ListUpdateItemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type ListRemoveItemResponder = {
  with200(): ExpressRuntimeResponse<{
    message?: string;
  }>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type ListRemoveItem = (
  params: Params<t_ListRemoveItemParamSchema, void, void, void>,
  respond: ListRemoveItemResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type ListsImplementation = {
  listIndex: ListIndex;
  listCreate: ListCreate;
  listShow: ListShow;
  listUpdate: ListUpdate;
  listDestroy: ListDestroy;
  listAddItem: ListAddItem;
  listUpdateItem: ListUpdateItem;
  listRemoveItem: ListRemoveItem;
};

export function createListsRouter(implementation: ListsImplementation): Router {
  const router = Router();

  const listIndexQuerySchema = z.object({
    visibility: z.enum(['public', 'private']).optional(),
    type: z.enum(['SERIES', 'CUSTOM']).optional(),
    userId: z.coerce.number().optional(),
    mediaId: z.coerce.number().optional(),
  });

  const listIndexResponseBodyValidator = responseValidationFactory(
    [
      ['200', z.array(s_List)],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // listIndex
  router.get(`/v1/lists`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: parseRequestInput(listIndexQuerySchema, req.query, RequestInputType.QueryString),
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_List[]>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.listIndex(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(listIndexResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const listCreateRequestBodySchema = s_ListCreateRequest;

  const listCreateResponseBodyValidator = responseValidationFactory(
    [
      ['201', s_List],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // listCreate
  router.post(`/v1/lists`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(listCreateRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with201() {
          return new ExpressRuntimeResponse<t_List>(201);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.listCreate(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(listCreateResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const listShowParamSchema = z.object({ id: z.coerce.number() });

  const listShowResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_ListWithMedia],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // listShow
  router.get(`/v1/lists/:id`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(listShowParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_ListWithMedia>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.listShow(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(listShowResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const listUpdateParamSchema = z.object({ id: z.coerce.number() });

  const listUpdateRequestBodySchema = z.object({
    name: z.string().optional(),
    visibility: z.enum(['PUBLIC', 'PRIVATE']).optional(),
  });

  const listUpdateResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_List],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // listUpdate
  router.patch(`/v1/lists/:id`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(listUpdateParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: parseRequestInput(listUpdateRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_List>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.listUpdate(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(listUpdateResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const listDestroyParamSchema = z.object({ id: z.coerce.number() });

  const listDestroyResponseBodyValidator = responseValidationFactory(
    [
      ['200', z.object({ message: z.string().optional(), id: z.coerce.number().optional() })],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // listDestroy
  router.delete(`/v1/lists/:id`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(listDestroyParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<{
            id?: number;
            message?: string;
          }>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.listDestroy(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(listDestroyResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const listAddItemParamSchema = z.object({ id: z.coerce.number() });

  const listAddItemRequestBodySchema = z.object({ mediaId: z.coerce.number(), position: z.coerce.number() });

  const listAddItemResponseBodyValidator = responseValidationFactory(
    [
      ['201', z.object({ message: z.string().optional() })],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // listAddItem
  router.post(`/v1/lists/:id/items`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(listAddItemParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: parseRequestInput(listAddItemRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with201() {
          return new ExpressRuntimeResponse<{
            message?: string;
          }>(201);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.listAddItem(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(listAddItemResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const listUpdateItemParamSchema = z.object({ id: z.coerce.number(), mediaId: z.coerce.number() });

  const listUpdateItemRequestBodySchema = z.object({ position: z.coerce.number() });

  const listUpdateItemResponseBodyValidator = responseValidationFactory(
    [
      ['200', z.object({ message: z.string().optional() })],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // listUpdateItem
  router.patch(`/v1/lists/:id/items/:mediaId`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(listUpdateItemParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: parseRequestInput(listUpdateItemRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<{
            message?: string;
          }>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.listUpdateItem(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(listUpdateItemResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const listRemoveItemParamSchema = z.object({ id: z.coerce.number(), mediaId: z.coerce.number() });

  const listRemoveItemResponseBodyValidator = responseValidationFactory(
    [
      ['200', z.object({ message: z.string().optional() })],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // listRemoveItem
  router.delete(`/v1/lists/:id/items/:mediaId`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: parseRequestInput(listRemoveItemParamSchema, req.params, RequestInputType.RouteParam),
        query: undefined,
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<{
            message?: string;
          }>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.listRemoveItem(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(listRemoveItemResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  return router;
}

export { createListsRouter as createRouter };
export type { ListsImplementation as Implementation };
