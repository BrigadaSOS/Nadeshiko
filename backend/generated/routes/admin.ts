/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  ExpressRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-express-runtime/errors"
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  SkipResponse,
  type StatusCode,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod-v3"
import { type NextFunction, type Request, type Response, Router } from "express"
import { z } from "zod/v3"
import type {
  t_DatabaseSyncResponse,
  t_Error,
  t_ReindexMediaSegmentsParamSchema,
  t_ReindexMediaSegmentsRequestBodySchema,
  t_ReindexSegmentParamSchema,
  t_SyncSpecificMediaRequestBodySchema,
} from "../models.ts"
import type { SyncSpecificMediaRequestOutput } from '../outputTypes.ts';
import {
  PermissiveBoolean,
  s_DatabaseSyncResponse,
  s_Error,
  s_SyncSpecificMediaRequest,
} from "../schemas.ts"

export type ReSyncDatabaseResponder = {
  with200(): ExpressRuntimeResponse<t_DatabaseSyncResponse>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ReSyncDatabase = (
  params: Params<void, void, void, void>,
  respond: ReSyncDatabaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReSyncDatabasePartialResponder = {
  with200(): ExpressRuntimeResponse<t_DatabaseSyncResponse>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ReSyncDatabasePartial = (
  params: Params<void, void, void, void>,
  respond: ReSyncDatabasePartialResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReindexSegmentResponder = {
  with200(): ExpressRuntimeResponse<{
    message?: string
  }>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ReindexSegment = (
  params: Params<t_ReindexSegmentParamSchema, void, void, void>,
  respond: ReindexSegmentResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReindexMediaSegmentsResponder = {
  with202(): ExpressRuntimeResponse<{
    episode?: number | null
    media_id?: number
    message?: string
    reindex_id?: string
    season?: number | null
  }>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ReindexMediaSegments = (
  params: Params<
    t_ReindexMediaSegmentsParamSchema,
    void,
    t_ReindexMediaSegmentsRequestBodySchema | undefined,
    void
  >,
  respond: ReindexMediaSegmentsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type ReindexFullDatabaseResponder = {
  with202(): ExpressRuntimeResponse<{
    message?: string
    reindex_id?: string
  }>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type ReindexFullDatabase = (
  params: Params<void, void, void, void>,
  respond: ReindexFullDatabaseResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetReindexStatusResponder = {
  with200(): ExpressRuntimeResponse<{
    failed_sync_count?: number
    failed_sync_logs?: {
      created_at?: string
      error_message?: string | null
      id?: number
      operation?: "CREATE" | "UPDATE" | "DELETE"
      record_id?: number
      retry_count?: number
      table_name?: string
    }[]
    operations?: {
      completed_at?: string | null
      reindex_id?: string
      result?: {
        deleted?: number
        errors?: string[]
        failed?: number
        indexed?: number
        success?: boolean
      }
      started_at?: string
      status?: "running" | "completed" | "failed"
    }[]
  }>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetReindexStatus = (
  params: Params<void, void, void, void>,
  respond: GetReindexStatusResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SyncSpecificMediaResponder = {
  with200(): ExpressRuntimeResponse<t_DatabaseSyncResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type SyncSpecificMedia = (
  params: Params<void, void, SyncSpecificMediaRequestOutput, void>,
  respond: SyncSpecificMediaResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AdminImplementation = {
  reSyncDatabase: ReSyncDatabase
  reSyncDatabasePartial: ReSyncDatabasePartial
  reindexSegment: ReindexSegment
  reindexMediaSegments: ReindexMediaSegments
  reindexFullDatabase: ReindexFullDatabase
  getReindexStatus: GetReindexStatus
  syncSpecificMedia: SyncSpecificMedia
}

export function createAdminRouter(implementation: AdminImplementation): Router {
  const router = Router()

  const reSyncDatabaseResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_DatabaseSyncResponse],
      ["401", s_Error],
      ["403", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // reSyncDatabase
  router.post(
    `/v1/admin/database/sync/full`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_DatabaseSyncResponse>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .reSyncDatabase(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(reSyncDatabaseResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const reSyncDatabasePartialResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_DatabaseSyncResponse],
      ["401", s_Error],
      ["403", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // reSyncDatabasePartial
  router.post(
    `/v1/admin/database/sync/partial`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_DatabaseSyncResponse>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .reSyncDatabasePartial(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(reSyncDatabasePartialResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const reindexSegmentParamSchema = z.object({ segmentId: z.coerce.number() })

  const reindexSegmentResponseBodyValidator = responseValidationFactory(
    [
      ["200", z.object({ message: z.string().optional() })],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // reindexSegment
  router.post(
    `/v1/admin/database/reindex/segment/:segmentId`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reindexSegmentParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              message?: string
            }>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .reindexSegment(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(reindexSegmentResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const reindexMediaSegmentsParamSchema = z.object({
    mediaId: z.coerce.number(),
  })

  const reindexMediaSegmentsRequestBodySchema = z
    .object({
      season: z.coerce.number().optional(),
      episode: z.coerce.number().optional(),
    })
    .optional()

  const reindexMediaSegmentsResponseBodyValidator = responseValidationFactory(
    [
      [
        "202",
        z.object({
          message: z.string().optional(),
          reindex_id: z.string().optional(),
          media_id: z.coerce.number().optional(),
          season: z.coerce.number().nullable().optional(),
          episode: z.coerce.number().nullable().optional(),
        }),
      ],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
    ],
    undefined,
  )

  // reindexMediaSegments
  router.post(
    `/v1/admin/database/reindex/media/:mediaId/segments`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: parseRequestInput(
            reindexMediaSegmentsParamSchema,
            req.params,
            RequestInputType.RouteParam,
          ),
          query: undefined,
          body: parseRequestInput(
            reindexMediaSegmentsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              episode?: number | null
              media_id?: number
              message?: string
              reindex_id?: string
              season?: number | null
            }>(202)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .reindexMediaSegments(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(reindexMediaSegmentsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const reindexFullDatabaseResponseBodyValidator = responseValidationFactory(
    [
      [
        "202",
        z.object({
          message: z.string().optional(),
          reindex_id: z.string().optional(),
        }),
      ],
      ["401", s_Error],
      ["403", s_Error],
    ],
    undefined,
  )

  // reindexFullDatabase
  router.post(
    `/v1/admin/database/reindex/database`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with202() {
            return new ExpressRuntimeResponse<{
              message?: string
              reindex_id?: string
            }>(202)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .reindexFullDatabase(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(reindexFullDatabaseResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getReindexStatusResponseBodyValidator = responseValidationFactory(
    [
      [
        "200",
        z.object({
          operations: z
            .array(
              z.object({
                reindex_id: z.string().optional(),
                status: z.enum(["running", "completed", "failed"]).optional(),
                started_at: z.string().datetime({ offset: true }).optional(),
                completed_at: z
                  .string()
                  .datetime({ offset: true })
                  .nullable()
                  .optional(),
                result: z
                  .object({
                    success: PermissiveBoolean.optional(),
                    indexed: z.coerce.number().optional(),
                    failed: z.coerce.number().optional(),
                    deleted: z.coerce.number().optional(),
                    errors: z.array(z.string()).optional(),
                  })
                  .optional(),
              }),
            )
            .optional(),
          failed_sync_count: z.coerce.number().optional(),
          failed_sync_logs: z
            .array(
              z.object({
                id: z.coerce.number().optional(),
                table_name: z.string().optional(),
                record_id: z.coerce.number().optional(),
                operation: z.enum(["CREATE", "UPDATE", "DELETE"]).optional(),
                error_message: z.string().nullable().optional(),
                retry_count: z.coerce.number().optional(),
                created_at: z.string().datetime({ offset: true }).optional(),
              }),
            )
            .optional(),
        }),
      ],
      ["401", s_Error],
      ["403", s_Error],
    ],
    undefined,
  )

  // getReindexStatus
  router.get(
    `/v1/admin/database/reindex/status`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<{
              failed_sync_count?: number
              failed_sync_logs?: {
                created_at?: string
                error_message?: string | null
                id?: number
                operation?: "CREATE" | "UPDATE" | "DELETE"
                record_id?: number
                retry_count?: number
                table_name?: string
              }[]
              operations?: {
                completed_at?: string | null
                reindex_id?: string
                result?: {
                  deleted?: number
                  errors?: string[]
                  failed?: number
                  indexed?: number
                  success?: boolean
                }
                started_at?: string
                status?: "running" | "completed" | "failed"
              }[]
            }>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getReindexStatus(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getReindexStatusResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const syncSpecificMediaRequestBodySchema = s_SyncSpecificMediaRequest

  const syncSpecificMediaResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_DatabaseSyncResponse],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // syncSpecificMedia
  router.post(
    `/v1/management/media/sync/media`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            syncSpecificMediaRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_DatabaseSyncResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .syncSpecificMedia(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(syncSpecificMediaResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export { createAdminRouter as createRouter }
export type { AdminImplementation as Implementation }
