/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  ExpressRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-express-runtime/errors"
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  SkipResponse,
  type StatusCode,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod-v3"
import { type NextFunction, type Request, type Response, Router } from "express"
import { z } from "zod/v3"
import type {
  t_DiscordAuthUrlResponse,
  t_Error,
  t_GetDiscordAuthUrlRequestHeaderSchema,
  t_LoginDiscordRequestBodySchema,
  t_LoginDiscordRequestHeaderSchema,
  t_LoginGoogleRequestBodySchema,
  t_LoginGoogleRequestHeaderSchema,
  t_LoginRequestBodySchema,
  t_LoginRequestHeaderSchema,
  t_LoginResponse,
  t_RegisterRequestBodySchema,
  t_RegisterRequestHeaderSchema,
  t_RegisterResponse,
} from "../models.ts"
import type { DiscordLoginRequestOutput, GoogleLoginRequestOutput, LoginRequestOutput, RegisterRequestOutput } from '../outputTypes.ts';
import {
  s_DiscordAuthUrlResponse,
  s_DiscordLoginRequest,
  s_Error,
  s_GoogleLoginRequest,
  s_LoginRequest,
  s_LoginResponse,
  s_RegisterRequest,
  s_RegisterResponse,
} from "../schemas.ts"

export type GetDiscordAuthUrlResponder = {
  with200(): ExpressRuntimeResponse<t_DiscordAuthUrlResponse>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetDiscordAuthUrl = (
  params: Params<void, void, void, t_GetDiscordAuthUrlRequestHeaderSchema>,
  respond: GetDiscordAuthUrlResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LoginDiscordResponder = {
  with200(): ExpressRuntimeResponse<t_LoginResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with409(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type LoginDiscord = (
  params: Params<
    void,
    void,
    DiscordLoginRequestOutput,
    t_LoginDiscordRequestHeaderSchema
  >,
  respond: LoginDiscordResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LoginGoogleResponder = {
  with200(): ExpressRuntimeResponse<t_LoginResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with409(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type LoginGoogle = (
  params: Params<
    void,
    void,
    GoogleLoginRequestOutput,
    t_LoginGoogleRequestHeaderSchema
  >,
  respond: LoginGoogleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type LoginResponder = {
  with200(): ExpressRuntimeResponse<t_LoginResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Login = (
  params: Params<
    void,
    void,
    LoginRequestOutput,
    t_LoginRequestHeaderSchema
  >,
  respond: LoginResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type RegisterResponder = {
  with201(): ExpressRuntimeResponse<t_RegisterResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with409(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type Register = (
  params: Params<
    void,
    void,
    RegisterRequestOutput,
    t_RegisterRequestHeaderSchema
  >,
  respond: RegisterResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type AuthImplementation = {
  getDiscordAuthUrl: GetDiscordAuthUrl
  loginDiscord: LoginDiscord
  loginGoogle: LoginGoogle
  login: Login
  register: Register
}

export function createAuthRouter(implementation: AuthImplementation): Router {
  const router = Router()

  const getDiscordAuthUrlRequestHeaderSchema = z.object({
    referer: z.string().optional(),
  })

  const getDiscordAuthUrlResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_DiscordAuthUrlResponse],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // getDiscordAuthUrl
  router.get(
    `/v1/auth/discord/url`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: parseRequestInput(
            getDiscordAuthUrlRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_DiscordAuthUrlResponse>(200)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getDiscordAuthUrl(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getDiscordAuthUrlResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const loginDiscordRequestHeaderSchema = z.object({
    referer: z.string().optional(),
  })

  const loginDiscordRequestBodySchema = s_DiscordLoginRequest

  const loginDiscordResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_LoginResponse],
      ["400", s_Error],
      ["409", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // loginDiscord
  router.post(
    `/v1/auth/discord`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            loginDiscordRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            loginDiscordRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_LoginResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with409() {
            return new ExpressRuntimeResponse<t_Error>(409)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .loginDiscord(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(loginDiscordResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const loginGoogleRequestHeaderSchema = z.object({
    referer: z.string().optional(),
  })

  const loginGoogleRequestBodySchema = s_GoogleLoginRequest

  const loginGoogleResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_LoginResponse],
      ["400", s_Error],
      ["409", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // loginGoogle
  router.post(
    `/v1/auth/google`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            loginGoogleRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            loginGoogleRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_LoginResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with409() {
            return new ExpressRuntimeResponse<t_Error>(409)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .loginGoogle(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(loginGoogleResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const loginRequestHeaderSchema = z.object({ referer: z.string().optional() })

  const loginRequestBodySchema = s_LoginRequest

  const loginResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_LoginResponse],
      ["400", s_Error],
      ["401", s_Error],
      ["404", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // login
  router.post(
    `/v1/auth/login`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            loginRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            loginRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_LoginResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .login(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(loginResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const registerRequestHeaderSchema = z.object({
    referer: z.string().optional(),
  })

  const registerRequestBodySchema = s_RegisterRequest

  const registerResponseBodyValidator = responseValidationFactory(
    [
      ["201", s_RegisterResponse],
      ["400", s_Error],
      ["409", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // register
  router.post(
    `/v1/auth/register`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            registerRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: parseRequestInput(
            registerRequestHeaderSchema,
            req.headers,
            RequestInputType.RequestHeader,
          ),
        }

        const responder = {
          with201() {
            return new ExpressRuntimeResponse<t_RegisterResponse>(201)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with409() {
            return new ExpressRuntimeResponse<t_Error>(409)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .register(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(registerResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export { createAuthRouter as createRouter }
export type { AuthImplementation as Implementation }
