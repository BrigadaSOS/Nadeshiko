/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import { ExpressRuntimeError, RequestInputType } from '@nahkies/typescript-express-runtime/errors';
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  SkipResponse,
  type StatusCode,
} from '@nahkies/typescript-express-runtime/server';
import { parseRequestInput, responseValidationFactory } from '@nahkies/typescript-express-runtime/zod-v3';
import { type NextFunction, type Request, type Response, Router } from 'express';
import { z } from 'zod/v3';
import type {
  t_Error,
  t_FetchMediaInfoQuerySchema,
  t_FetchMediaInfoResponse,
  t_FetchSentenceContextRequestBodySchema,
  t_FetchSentenceContextResponse,
  t_SearchHealthCheckResponse,
  t_SearchMultipleRequestBodySchema,
  t_SearchMultipleResponse,
  t_SearchRequestBodySchema,
  t_SearchResponse,
} from '../models.ts';
import type { FetchMediaInfoQueryOutput, FetchSentenceContextRequestOutput, SearchMultipleRequestOutput, SearchRequestOutput } from '../outputTypes.ts';
import {
  s_Error,
  s_FetchMediaInfoResponse,
  s_FetchSentenceContextRequest,
  s_FetchSentenceContextResponse,
  s_SearchHealthCheckResponse,
  s_SearchMultipleRequest,
  s_SearchMultipleResponse,
  s_SearchRequest,
  s_SearchResponse,
} from '../schemas.ts';

export type SearchHealthCheckResponder = {
  with200(): ExpressRuntimeResponse<t_SearchHealthCheckResponse>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type SearchHealthCheck = (
  params: Params<void, void, void, void>,
  respond: SearchHealthCheckResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type SearchResponder = {
  with200(): ExpressRuntimeResponse<t_SearchResponse>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type Search = (
  params: Params<void, void, SearchRequestOutput, void>,
  respond: SearchResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type SearchMultipleResponder = {
  with200(): ExpressRuntimeResponse<t_SearchMultipleResponse>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type SearchMultiple = (
  params: Params<void, void, SearchMultipleRequestOutput, void>,
  respond: SearchMultipleResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type FetchSentenceContextResponder = {
  with200(): ExpressRuntimeResponse<t_FetchSentenceContextResponse>;
  with400(): ExpressRuntimeResponse<t_Error>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with404(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type FetchSentenceContext = (
  params: Params<void, void, FetchSentenceContextRequestOutput, void>,
  respond: FetchSentenceContextResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type FetchMediaInfoResponder = {
  with200(): ExpressRuntimeResponse<t_FetchMediaInfoResponse>;
  with401(): ExpressRuntimeResponse<t_Error>;
  with403(): ExpressRuntimeResponse<t_Error>;
  with429(): ExpressRuntimeResponse<t_Error>;
  with500(): ExpressRuntimeResponse<t_Error>;
} & ExpressRuntimeResponder;

export type FetchMediaInfo = (
  params: Params<void, FetchMediaInfoQueryOutput, void, void>,
  respond: FetchMediaInfoResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>;

export type SearchImplementation = {
  searchHealthCheck: SearchHealthCheck;
  search: Search;
  searchMultiple: SearchMultiple;
  fetchSentenceContext: FetchSentenceContext;
  fetchMediaInfo: FetchMediaInfo;
};

export function createSearchRouter(implementation: SearchImplementation): Router {
  const router = Router();

  const searchHealthCheckResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_SearchHealthCheckResponse],
      ['401', s_Error],
      ['403', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // searchHealthCheck
  router.get(`/v1/search/health`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: undefined,
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_SearchHealthCheckResponse>(200);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.searchHealthCheck(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(searchHealthCheckResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const searchRequestBodySchema = s_SearchRequest;

  const searchResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_SearchResponse],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // search
  router.post(`/v1/search/media/sentence`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(searchRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_SearchResponse>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.search(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(searchResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const searchMultipleRequestBodySchema = s_SearchMultipleRequest;

  const searchMultipleResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_SearchMultipleResponse],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // searchMultiple
  router.post(`/v1/search/media/match/words`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(searchMultipleRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_SearchMultipleResponse>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.searchMultiple(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(searchMultipleResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const fetchSentenceContextRequestBodySchema = s_FetchSentenceContextRequest;

  const fetchSentenceContextResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_FetchSentenceContextResponse],
      ['400', s_Error],
      ['401', s_Error],
      ['403', s_Error],
      ['404', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // fetchSentenceContext
  router.post(`/v1/search/media/context`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: undefined,
        body: parseRequestInput(fetchSentenceContextRequestBodySchema, req.body, RequestInputType.RequestBody),
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_FetchSentenceContextResponse>(200);
        },
        with400() {
          return new ExpressRuntimeResponse<t_Error>(400);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with404() {
          return new ExpressRuntimeResponse<t_Error>(404);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.fetchSentenceContext(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(fetchSentenceContextResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  const fetchMediaInfoQuerySchema = z.object({
    size: z.coerce.number().optional().default(20),
    cursor: z.coerce.number().optional().default(0),
    query: z.string().optional(),
    type: z.enum(['anime', 'liveaction', 'audiobook']).optional(),
  });

  const fetchMediaInfoResponseBodyValidator = responseValidationFactory(
    [
      ['200', s_FetchMediaInfoResponse],
      ['401', s_Error],
      ['403', s_Error],
      ['429', s_Error],
      ['500', s_Error],
    ],
    undefined,
  );

  // fetchMediaInfo
  router.get(`/v1/search/media/info`, async (req: Request, res: Response, next: NextFunction) => {
    try {
      const input = {
        params: undefined,
        query: parseRequestInput(fetchMediaInfoQuerySchema, req.query, RequestInputType.QueryString),
        body: undefined,
        headers: undefined,
      };

      const responder = {
        with200() {
          return new ExpressRuntimeResponse<t_FetchMediaInfoResponse>(200);
        },
        with401() {
          return new ExpressRuntimeResponse<t_Error>(401);
        },
        with403() {
          return new ExpressRuntimeResponse<t_Error>(403);
        },
        with429() {
          return new ExpressRuntimeResponse<t_Error>(429);
        },
        with500() {
          return new ExpressRuntimeResponse<t_Error>(500);
        },
        withStatus(status: StatusCode) {
          return new ExpressRuntimeResponse(status);
        },
      };

      const response = await implementation.fetchMediaInfo(input, responder, req, res, next).catch((err) => {
        throw ExpressRuntimeError.HandlerError(err);
      });

      // escape hatch to allow responses to be sent by the implementation handler
      if (response === SkipResponse) {
        return;
      }

      const { status, body } = response instanceof ExpressRuntimeResponse ? response.unpack() : response;

      res.status(status);

      if (body !== undefined) {
        res.json(fetchMediaInfoResponseBodyValidator(status, body));
      } else {
        res.end();
      }
    } catch (error) {
      next(error);
    }
  });

  return router;
}

export { createSearchRouter as createRouter };
export type { SearchImplementation as Implementation };
