/** AUTOGENERATED - DO NOT EDIT **/
/* tslint:disable */
/* eslint-disable */

import {
  ExpressRuntimeError,
  RequestInputType,
} from "@nahkies/typescript-express-runtime/errors"
import {
  type ExpressRuntimeResponder,
  ExpressRuntimeResponse,
  type Params,
  type ServerConfig,
  SkipResponse,
  type StatusCode,
  startServer,
} from "@nahkies/typescript-express-runtime/server"
import {
  parseRequestInput,
  responseValidationFactory,
} from "@nahkies/typescript-express-runtime/zod-v3"
import { type NextFunction, type Request, type Response, Router } from "express"
import { z } from "zod/v3"
import type {
  t_ContextResponse,
  t_Error,
  t_GetContextSentenceRequestBodySchema,
  t_GetRecentMediaQuerySchema,
  t_MediaInfoResponse,
  t_ResponseV1,
  t_SearchMultipleWordsRequestBodySchema,
  t_SearchSentenceRequestBodySchema,
  t_WordsMatchedResponse,
} from "./models"
import {
  PermissiveBoolean,
  s_ContextRequest,
  s_ContextResponse,
  s_Error,
  s_MediaInfoResponse,
  s_ResponseV1,
  s_SentenceSearchRequest,
  s_WordsMatchedResponse,
} from "./schemas"

export type SearchHealthResponder = {
  with200(): ExpressRuntimeResponse<t_ResponseV1>
  with401(): ExpressRuntimeResponse<void>
} & ExpressRuntimeResponder

export type SearchHealth = (
  params: Params<void, void, void, void>,
  respond: SearchHealthResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SearchSentenceResponder = {
  with200(): ExpressRuntimeResponse<t_ResponseV1>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type SearchSentence = (
  params: Params<void, void, t_SearchSentenceRequestBodySchema, void>,
  respond: SearchSentenceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type SearchMultipleWordsResponder = {
  with200(): ExpressRuntimeResponse<t_WordsMatchedResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type SearchMultipleWords = (
  params: Params<void, void, t_SearchMultipleWordsRequestBodySchema, void>,
  respond: SearchMultipleWordsResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetContextSentenceResponder = {
  with200(): ExpressRuntimeResponse<t_ContextResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with404(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetContextSentence = (
  params: Params<void, void, t_GetContextSentenceRequestBodySchema, void>,
  respond: GetContextSentenceResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type GetRecentMediaResponder = {
  with200(): ExpressRuntimeResponse<t_MediaInfoResponse>
  with400(): ExpressRuntimeResponse<t_Error>
  with401(): ExpressRuntimeResponse<t_Error>
  with403(): ExpressRuntimeResponse<t_Error>
  with429(): ExpressRuntimeResponse<t_Error>
  with500(): ExpressRuntimeResponse<t_Error>
} & ExpressRuntimeResponder

export type GetRecentMedia = (
  params: Params<void, t_GetRecentMediaQuerySchema, void, void>,
  respond: GetRecentMediaResponder,
  req: Request,
  res: Response,
  next: NextFunction,
) => Promise<ExpressRuntimeResponse<unknown> | typeof SkipResponse>

export type Implementation = {
  searchHealth: SearchHealth
  searchSentence: SearchSentence
  searchMultipleWords: SearchMultipleWords
  getContextSentence: GetContextSentence
  getRecentMedia: GetRecentMedia
}

export function createRouter(implementation: Implementation): Router {
  const router = Router()

  const searchHealthResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ResponseV1],
      ["401", z.undefined()],
    ],
    undefined,
  )

  // searchHealth
  router.get(
    `/search/health`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ResponseV1>(200)
          },
          with401() {
            return new ExpressRuntimeResponse<void>(401)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .searchHealth(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(searchHealthResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const searchSentenceRequestBodySchema = s_SentenceSearchRequest

  const searchSentenceResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ResponseV1],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // searchSentence
  router.post(
    `/search/media/sentence`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            searchSentenceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ResponseV1>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .searchSentence(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(searchSentenceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const searchMultipleWordsRequestBodySchema = z.object({
    words: z.array(z.string()).optional(),
    exact_match: PermissiveBoolean.optional(),
  })

  const searchMultipleWordsResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_WordsMatchedResponse],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // searchMultipleWords
  router.post(
    `/search/media/match/words`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            searchMultipleWordsRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_WordsMatchedResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .searchMultipleWords(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(searchMultipleWordsResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getContextSentenceRequestBodySchema = s_ContextRequest

  const getContextSentenceResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_ContextResponse],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["404", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // getContextSentence
  router.post(
    `/search/media/context`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: undefined,
          body: parseRequestInput(
            getContextSentenceRequestBodySchema,
            req.body,
            RequestInputType.RequestBody,
          ),
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_ContextResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with404() {
            return new ExpressRuntimeResponse<t_Error>(404)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getContextSentence(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getContextSentenceResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  const getRecentMediaQuerySchema = z.object({
    size: z.coerce.number().optional().default(10),
    sorted: PermissiveBoolean.optional().default(true),
    query: z.string().optional(),
    type: z.enum(["anime", "liveaction", "audiobook"]).optional(),
    cursor: z.coerce.number().optional(),
  })

  const getRecentMediaResponseBodyValidator = responseValidationFactory(
    [
      ["200", s_MediaInfoResponse],
      ["400", s_Error],
      ["401", s_Error],
      ["403", s_Error],
      ["429", s_Error],
      ["500", s_Error],
    ],
    undefined,
  )

  // getRecentMedia
  router.get(
    `/search/media/info`,
    async (req: Request, res: Response, next: NextFunction) => {
      try {
        const input = {
          params: undefined,
          query: parseRequestInput(
            getRecentMediaQuerySchema,
            req.query,
            RequestInputType.QueryString,
          ),
          body: undefined,
          headers: undefined,
        }

        const responder = {
          with200() {
            return new ExpressRuntimeResponse<t_MediaInfoResponse>(200)
          },
          with400() {
            return new ExpressRuntimeResponse<t_Error>(400)
          },
          with401() {
            return new ExpressRuntimeResponse<t_Error>(401)
          },
          with403() {
            return new ExpressRuntimeResponse<t_Error>(403)
          },
          with429() {
            return new ExpressRuntimeResponse<t_Error>(429)
          },
          with500() {
            return new ExpressRuntimeResponse<t_Error>(500)
          },
          withStatus(status: StatusCode) {
            return new ExpressRuntimeResponse(status)
          },
        }

        const response = await implementation
          .getRecentMedia(input, responder, req, res, next)
          .catch((err) => {
            throw ExpressRuntimeError.HandlerError(err)
          })

        // escape hatch to allow responses to be sent by the implementation handler
        if (response === SkipResponse) {
          return
        }

        const { status, body } =
          response instanceof ExpressRuntimeResponse
            ? response.unpack()
            : response

        res.status(status)

        if (body !== undefined) {
          res.json(getRecentMediaResponseBodyValidator(status, body))
        } else {
          res.end()
        }
      } catch (error) {
        next(error)
      }
    },
  )

  return router
}

export async function bootstrap(config: ServerConfig) {
  // Nadeshiko API
  return startServer(config)
}
